<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>👻 Haunted AR Camera - Real-time Ghost Video Recorder</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Courier New', monospace;
            background: linear-gradient(135deg, #0a0015, #1a0033, #000000);
            color: #ffffff;
            overflow-x: hidden;
            user-select: none;
        }

        .app-container {
            position: relative;
            width: 100vw;
            height: 100vh;
            display: flex;
            flex-direction: column;
        }

        .header {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            z-index: 100;
            background: linear-gradient(135deg, rgba(26,0,51,0.9), rgba(0,0,0,0.8));
            backdrop-filter: blur(10px);
            padding: 15px 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .title {
            font-size: 20px;
            font-weight: bold;
            color: #ffff00;
            text-shadow: 2px 2px 4px #ff0000;
            animation: pulse 2s ease-in-out infinite alternate;
        }

        .status-indicator {
            display: flex;
            align-items: center;
            gap: 10px;
            font-size: 12px;
        }

        .recording-dot {
            width: 10px;
            height: 10px;
            background: #ff0000;
            border-radius: 50%;
            animation: blink 1s ease-in-out infinite;
        }

        @keyframes pulse {
            from { transform: scale(1); }
            to { transform: scale(1.05); }
        }

        @keyframes blink {
            0%, 50% { opacity: 1; }
            51%, 100% { opacity: 0.3; }
        }

        @keyframes float {
            0%, 100% { transform: translateY(0px) translateX(0px) rotate(0deg); }
            25% { transform: translateY(-15px) translateX(5px) rotate(2deg); }
            50% { transform: translateY(-5px) translateX(-3px) rotate(-1deg); }
            75% { transform: translateY(-20px) translateX(8px) rotate(3deg); }
        }

        @keyframes spookDrift {
            0% { transform: translateX(-100px) opacity(0); }
            10% { opacity: 0.7; }
            90% { opacity: 0.4; }
            100% { transform: translateX(calc(100vw + 100px)) opacity(0); }
        }

        @keyframes eyeGlow {
            0%, 100% { filter: drop-shadow(0 0 5px #ff0000); }
            50% { filter: drop-shadow(0 0 20px #ff0000) drop-shadow(0 0 30px #ff0000); }
        }

        .video-container {
            flex: 1;
            position: relative;
            background: #000000;
            overflow: hidden;
        }

        #video {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        #arCanvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 10;
        }

        .ar-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 5;
        }

        .ghost-entity {
            position: absolute;
            font-size: 60px;
            opacity: 0;
            transition: opacity 0.5s ease;
            filter: drop-shadow(0 0 10px rgba(255,255,255,0.3));
            z-index: 8;
        }

        .floating-ghost {
            animation: float 4s ease-in-out infinite;
        }

        .drifting-shadow {
            animation: spookDrift 8s linear infinite;
            animation-delay: var(--delay);
        }

        .watching-eyes {
            animation: eyeGlow 2s ease-in-out infinite;
            font-size: 30px;
        }

        .scanning-grid {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-image: 
                linear-gradient(rgba(0,255,0,0.1) 1px, transparent 1px),
                linear-gradient(90deg, rgba(0,255,0,0.1) 1px, transparent 1px);
            background-size: 50px 50px;
            opacity: 0;
            transition: opacity 0.5s ease;
            animation: scanMove 3s linear infinite;
        }

        @keyframes scanMove {
            0% { transform: translateY(-50px); }
            100% { transform: translateY(50px); }
        }

        .glitch-effect {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: repeating-linear-gradient(
                0deg,
                transparent,
                transparent 2px,
                rgba(255,0,0,0.1) 2px,
                rgba(255,0,0,0.1) 4px
            );
            opacity: 0;
            animation: glitch 0.3s ease-in-out infinite;
        }

        @keyframes glitch {
            0%, 90%, 100% { opacity: 0; }
            10%, 80% { opacity: 0.8; transform: translateX(2px); }
            20%, 70% { opacity: 0.6; transform: translateX(-2px); }
            30%, 60% { opacity: 0.9; transform: translateX(1px); }
            40%, 50% { opacity: 0.7; transform: translateX(-1px); }
        }

        .controls {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            background: linear-gradient(0deg, rgba(0,0,0,0.9), rgba(0,0,0,0.7), transparent);
            padding: 30px 20px 40px;
            z-index: 100;
        }

        .effect-selector {
            display: flex;
            justify-content: space-around;
            margin-bottom: 20px;
            gap: 8px;
        }

        .effect-btn {
            background: rgba(255,255,255,0.1);
            border: 2px solid #666;
            color: #ffffff;
            padding: 8px 12px;
            border-radius: 20px;
            font-size: 11px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            font-family: inherit;
            flex: 1;
            text-align: center;
        }

        .effect-btn:hover, .effect-btn.active {
            background: linear-gradient(135deg, #ff0000, #990000);
            border-color: #ffff00;
            transform: scale(1.05);
            box-shadow: 0 0 15px rgba(255,0,0,0.5);
        }

        .main-controls {
            display: flex;
            justify-content: space-around;
            align-items: center;
        }

        .control-btn {
            background: rgba(255,255,255,0.1);
            border: 2px solid #666;
            color: #ffffff;
            width: 60px;
            height: 60px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 24px;
        }

        .control-btn:hover {
            transform: scale(1.1);
            box-shadow: 0 0 20px rgba(255,255,255,0.3);
        }

        .record-btn {
            background: linear-gradient(135deg, #ff0000, #990000);
            border-color: #ffff00;
            width: 80px;
            height: 80px;
            font-size: 28px;
            position: relative;
        }

        .record-btn.recording {
            animation: recordPulse 1s ease-in-out infinite;
        }

        .record-btn.recording::after {
            content: '';
            position: absolute;
            top: -5px;
            left: -5px;
            right: -5px;
            bottom: -5px;
            border: 3px solid #ff0000;
            border-radius: 50%;
            animation: ringPulse 2s ease-in-out infinite;
        }

        @keyframes recordPulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.1); }
        }

        @keyframes ringPulse {
            0% { transform: scale(1); opacity: 1; }
            100% { transform: scale(1.5); opacity: 0; }
        }

        .timer {
            position: absolute;
            top: 80px;
            right: 20px;
            background: rgba(255,0,0,0.8);
            color: white;
            padding: 8px 12px;
            border-radius: 15px;
            font-size: 14px;
            font-weight: bold;
            z-index: 100;
            display: none;
        }

        .timer.show {
            display: block;
            animation: timerBlink 1s ease-in-out infinite;
        }

        @keyframes timerBlink {
            0%, 50% { opacity: 1; }
            51%, 100% { opacity: 0.7; }
        }

        .preview-modal {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0,0,0,0.95);
            z-index: 1000;
            display: none;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 20px;
        }

        .preview-modal.show {
            display: flex;
        }

        .preview-video {
            max-width: 90%;
            max-height: 70%;
            border: 3px solid #ff0000;
            border-radius: 15px;
            box-shadow: 0 0 30px rgba(255,0,0,0.5);
        }

        .preview-controls {
            margin-top: 20px;
            display: flex;
            gap: 15px;
            flex-wrap: wrap;
            justify-content: center;
        }

        .preview-btn {
            background: linear-gradient(135deg, #6600cc, #9900ff);
            border: 2px solid #ffff00;
            color: #ffffff;
            padding: 12px 20px;
            border-radius: 25px;
            font-size: 14px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            font-family: inherit;
        }

        .preview-btn:hover {
            background: linear-gradient(135deg, #9900ff, #cc00ff);
            transform: scale(1.05);
            box-shadow: 0 0 15px rgba(153,0,255,0.5);
        }

        .preview-btn.close {
            background: linear-gradient(135deg, #ff0000, #cc0000);
        }

        .effect-info {
            position: absolute;
            top: 120px;
            left: 20px;
            right: 20px;
            background: rgba(0,0,0,0.7);
            padding: 10px;
            border-radius: 10px;
            font-size: 12px;
            text-align: center;
            z-index: 100;
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        .effect-info.show {
            opacity: 1;
        }

        .motion-indicator {
            position: absolute;
            top: 150px;
            right: 20px;
            width: 20px;
            height: 20px;
            background: #00ff00;
            border-radius: 50%;
            opacity: 0;
            animation: motionPulse 0.5s ease-in-out;
            z-index: 100;
        }

        @keyframes motionPulse {
            0% { transform: scale(0); opacity: 1; }
            100% { transform: scale(1.5); opacity: 0; }
        }

        /* Mobile optimizations */
        @media (max-width: 480px) {
            .title {
                font-size: 16px;
            }
            
            .effect-btn {
                font-size: 10px;
                padding: 6px 8px;
            }
            
            .control-btn {
                width: 50px;
                height: 50px;
                font-size: 20px;
            }
            
            .record-btn {
                width: 70px;
                height: 70px;
                font-size: 24px;
            }
        }
    </style>
</head>
<body>
    <div class="app-container">
        <!-- Header -->
        <div class="header">
            <div class="title">👻 HAUNTED AR</div>
            <div class="status-indicator">
                <div class="recording-dot" id="recordingDot" style="display: none;"></div>
                <span id="statusText">Ready to record</span>
            </div>
        </div>

        <!-- Timer -->
        <div class="timer" id="timer">00:00</div>

        <!-- Video Container -->
        <div class="video-container">
            <video id="video" autoplay muted playsinline></video>
            <canvas id="arCanvas"></canvas>
            
            <!-- AR Overlay Effects -->
            <div class="ar-overlay" id="arOverlay">
                <div class="scanning-grid" id="scanningGrid"></div>
                <div class="glitch-effect" id="glitchEffect"></div>
            </div>
        </div>

        <!-- Effect Info -->
        <div class="effect-info" id="effectInfo">
            <span id="effectDescription">Select an effect to begin haunting</span>
        </div>

        <!-- Motion Indicator -->
        <div class="motion-indicator" id="motionIndicator"></div>

        <!-- Controls -->
        <div class="controls">
            <!-- Effect Selector -->
            <div class="effect-selector">
                <button class="effect-btn active" data-effect="none">NORMAL</button>
                <button class="effect-btn" data-effect="ghosts">GHOSTS</button>
                <button class="effect-btn" data-effect="shadows">SHADOWS</button>
                <button class="effect-btn" data-effect="eyes">EYES</button>
                <button class="effect-btn" data-effect="demon">DEMON</button>
            </div>

            <!-- Main Controls -->
            <div class="main-controls">
                <button class="control-btn" id="switchCamera" title="Switch Camera">🔄</button>
                <button class="control-btn record-btn" id="recordBtn" title="Record Video">📹</button>
                <button class="control-btn" id="galleryBtn" title="View Recordings">🎬</button>
            </div>
        </div>
    </div>

    <!-- Preview Modal -->
    <div class="preview-modal" id="previewModal">
        <video class="preview-video" id="previewVideo" controls></video>
        <div class="preview-controls">
            <button class="preview-btn" id="shareBtn">📤 Share</button>
            <button class="preview-btn" id="downloadBtn">💾 Download</button>
            <button class="preview-btn" id="recordAgainBtn">🎬 Record Again</button>
            <button class="preview-btn close" id="closePreviewBtn">✖ Close</button>
        </div>
    </div>

    <script>
        class HauntedARCamera {
            constructor() {
                this.video = document.getElementById('video');
                this.canvas = document.getElementById('arCanvas');
                this.ctx = this.canvas.getContext('2d');
                this.isRecording = false;
                this.mediaRecorder = null;
                this.recordedChunks = [];
                this.currentEffect = 'none';
                this.ghosts = [];
                this.shadows = [];
                this.eyes = [];
                this.animationId = null;
                this.startTime = 0;
                this.maxRecordTime = 60; // 60 seconds max
                this.motionDetection = {
                    lastImageData: null,
                    threshold: 30,
                    sensitivity: 0.1
                };
                
                this.effects = {
                    none: { description: "No effects - just normal recording" },
                    ghosts: { description: "Floating spirits appear around you" },
                    shadows: { description: "Dark figures lurk in the shadows" },
                    eyes: { description: "Watching eyes follow your movement" },
                    demon: { description: "Demonic presence with glitch effects" }
                };

                this.init();
            }

            async init() {
                await this.setupCamera();
                this.setupCanvas();
                this.setupEventListeners();
                this.startARLoop();
                this.setupMotionDetection();
            }

            async setupCamera() {
                try {
                    const stream = await navigator.mediaDevices.getUserMedia({
                        video: { 
                            facingMode: 'user',
                            width: { ideal: 1280 },
                            height: { ideal: 720 }
                        },
                        audio: true
                    });
                    this.video.srcObject = stream;
                    this.stream = stream;
                    this.updateStatus('Camera ready - select an effect');
                } catch (error) {
                    console.error('Camera error:', error);
                    this.updateStatus('Camera access denied');
                }
            }

            setupCanvas() {
                const resizeCanvas = () => {
                    this.canvas.width = this.video.videoWidth || window.innerWidth;
                    this.canvas.height = this.video.videoHeight || window.innerHeight;
                };

                this.video.addEventListener('loadedmetadata', resizeCanvas);
                window.addEventListener('resize', resizeCanvas);
                resizeCanvas();
            }

            setupEventListeners() {
                // Effect buttons
                document.querySelectorAll('.effect-btn').forEach(btn => {
                    btn.addEventListener('click', (e) => {
                        document.querySelectorAll('.effect-btn').forEach(b => b.classList.remove('active'));
                        e.target.classList.add('active');
                        this.currentEffect = e.target.dataset.effect;
                        this.updateEffectInfo();
                        this.resetEffects();
                    });
                });

                // Control buttons
                document.getElementById('recordBtn').addEventListener('click', () => this.toggleRecording());
                document.getElementById('switchCamera').addEventListener('click', () => this.switchCamera());
                
                // Preview controls
                document.getElementById('shareBtn').addEventListener('click', () => this.shareVideo());
                document.getElementById('downloadBtn').addEventListener('click', () => this.downloadVideo());
                document.getElementById('recordAgainBtn').addEventListener('click', () => this.recordAgain());
                document.getElementById('closePreviewBtn').addEventListener('click', () => this.closePreview());
            }

            setupMotionDetection() {
                setInterval(() => {
                    if (this.currentEffect !== 'none' && !this.isRecording) {
                        this.detectMotion();
                    }
                }, 200);
            }

            detectMotion() {
                if (!this.video.videoWidth || !this.video.videoHeight) return;

                const tempCanvas = document.createElement('canvas');
                const tempCtx = tempCanvas.getContext('2d');
                tempCanvas.width = this.video.videoWidth / 4; // Reduce resolution for performance
                tempCanvas.height = this.video.videoHeight / 4;

                tempCtx.drawImage(this.video, 0, 0, tempCanvas.width, tempCanvas.height);
                const currentImageData = tempCtx.getImageData(0, 0, tempCanvas.width, tempCanvas.height);

                if (this.motionDetection.lastImageData) {
                    const diff = this.calculateImageDifference(
                        this.motionDetection.lastImageData,
                        currentImageData
                    );

                    if (diff > this.motionDetection.threshold) {
                        this.triggerMotionEffect();
                    }
                }

                this.motionDetection.lastImageData = currentImageData;
            }

            calculateImageDifference(imageData1, imageData2) {
                let diff = 0;
                for (let i = 0; i < imageData1.data.length; i += 4) {
                    const r1 = imageData1.data[i];
                    const g1 = imageData1.data[i + 1];
                    const b1 = imageData1.data[i + 2];
                    
                    const r2 = imageData2.data[i];
                    const g2 = imageData2.data[i + 1];
                    const b2 = imageData2.data[i + 2];
                    
                    diff += Math.abs(r1 - r2) + Math.abs(g1 - g2) + Math.abs(b1 - b2);
                }
                return diff / (imageData1.data.length / 4);
            }

            triggerMotionEffect() {
                // Show motion indicator
                const indicator = document.getElementById('motionIndicator');
                indicator.style.opacity = '1';
                indicator.style.animation = 'motionPulse 0.5s ease-in-out';

                setTimeout(() => {
                    indicator.style.opacity = '0';
                }, 500);

                // Trigger effect based on current mode
                switch (this.currentEffect) {
                    case 'ghosts':
                        this.spawnGhost();
                        break;
                    case 'shadows':
                        this.spawnShadow();
                        break;
                    case 'eyes':
                        this.spawnEyes();
                        break;
                    case 'demon':
                        this.triggerDemonEffect();
                        break;
                }
            }

            spawnGhost() {
                const ghost = {
                    x: Math.random() * this.canvas.width,
                    y: Math.random() * this.canvas.height,
                    size: 80 + Math.random() * 120,
                    opacity: 0.2 + Math.random() * 0.3,
                    vx: (Math.random() - 0.5) * 1.5,
                    vy: (Math.random() - 0.5) * 1.5,
                    life: 4000 + Math.random() * 3000,
                    type: ['wispy', 'solid', 'orb'][Math.floor(Math.random() * 3)],
                    pulsePhase: Math.random() * Math.PI * 2,
                    fadeDirection: Math.random() > 0.5 ? 1 : -1
                };
                this.ghosts.push(ghost);
            }

            spawnShadow() {
                const shadow = {
                    x: Math.random() > 0.5 ? -150 : this.canvas.width + 150,
                    y: this.canvas.height * 0.7 + Math.random() * (this.canvas.height * 0.3),
                    width: 60 + Math.random() * 40,
                    height: 120 + Math.random() * 80,
                    opacity: 0.6 + Math.random() * 0.3,
                    speed: (Math.random() + 0.5) * (Math.random() > 0.5 ? 1 : -1),
                    life: 6000,
                    sway: Math.random() * 0.02,
                    swayPhase: Math.random() * Math.PI * 2
                };
                this.shadows.push(shadow);
            }

            spawnEyes() {
                const eyes = {
                    x: Math.random() * this.canvas.width,
                    y: Math.random() * this.canvas.height * 0.6,
                    size: 15 + Math.random() * 25,
                    opacity: 0.7 + Math.random() * 0.3,
                    glowIntensity: Math.random(),
                    life: 5000 + Math.random() * 4000,
                    blinkTimer: 0,
                    isBlinking: false,
                    pupilSize: 0.3 + Math.random() * 0.4
                };
                this.eyes.push(eyes);
            }

            triggerDemonEffect() {
                // Enhanced glitch effect
                const glitch = document.getElementById('glitchEffect');
                glitch.style.opacity = '0.8';
                glitch.style.background = `
                    repeating-linear-gradient(
                        ${Math.random() * 360}deg,
                        transparent,
                        transparent 2px,
                        rgba(255,0,0,0.3) 2px,
                        rgba(255,0,0,0.3) 4px
                    )
                `;
                
                setTimeout(() => {
                    glitch.style.opacity = '0';
                }, 500);

                // Spawn dark presence
                const demon = {
                    x: this.canvas.width * 0.5,
                    y: this.canvas.height * 0.3,
                    size: 150 + Math.random() * 100,
                    opacity: 0.8,
                    vx: 0,
                    vy: 0,
                    life: 3000,
                    type: 'demon',
                    intensity: 1,
                    pulsePhase: 0
                };
                this.ghosts.push(demon);

                // Add screen distortion
                this.addScreenDistortion();
            }

            startARLoop() {
                const animate = () => {
                    this.updateEffects();
                    this.renderEffects();
                    this.animationId = requestAnimationFrame(animate);
                };
                animate();
            }

            updateEffects() {
                const now = Date.now();

                // Update ghosts
                this.ghosts = this.ghosts.filter(ghost => {
                    ghost.x += ghost.vx;
                    ghost.y += ghost.vy;
                    ghost.life -= 16; // ~60fps
                    
                    // Boundary bouncing
                    if (ghost.x < 0 || ghost.x > this.canvas.width) ghost.vx *= -1;
                    if (ghost.y < 0 || ghost.y > this.canvas.height) ghost.vy *= -1;
                    
                    return ghost.life > 0;
                });

                // Update shadows
                this.shadows = this.shadows.filter(shadow => {
                    shadow.x += shadow.speed;
                    shadow.life -= 16;
                    return shadow.life > 0 && shadow.x < this.canvas.width + 100;
                });

                // Update eyes
                this.eyes = this.eyes.filter(eyes => {
                    eyes.life -= 16;
                    eyes.glowIntensity = Math.sin(now * 0.005) * 0.5 + 0.5;
                    return eyes.life > 0;
                });
            }

            renderEffects() {
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);

                // Render ghosts with realistic effects
                this.ghosts.forEach(ghost => {
                    this.ctx.save();
                    this.ctx.globalAlpha = ghost.opacity * (0.5 + 0.5 * Math.sin(ghost.pulsePhase));
                    
                    if (ghost.type === 'demon') {
                        this.drawDemonicPresence(ghost);
                    } else if (ghost.type === 'wispy') {
                        this.drawWispyGhost(ghost);
                    } else if (ghost.type === 'solid') {
                        this.drawSolidGhost(ghost);
                    } else if (ghost.type === 'orb') {
                        this.drawGhostOrb(ghost);
                    }
                    
                    this.ctx.restore();
                });

                // Render realistic shadow figures
                this.shadows.forEach(shadow => {
                    this.ctx.save();
                    this.ctx.globalAlpha = shadow.opacity;
                    this.drawShadowFigure(shadow);
                    this.ctx.restore();
                });

                // Render realistic eyes
                this.eyes.forEach(eyes => {
                    this.ctx.save();
                    this.ctx.globalAlpha = eyes.opacity;
                    this.drawRealisticEyes(eyes);
                    this.ctx.restore();
                });
            }

            drawWispyGhost(ghost) {
                const centerX = ghost.x;
                const centerY = ghost.y;
                const radius = ghost.size / 2;

                // Create wispy, translucent form
                const gradient = this.ctx.createRadialGradient(
                    centerX, centerY, 0,
                    centerX, centerY, radius
                );
                gradient.addColorStop(0, 'rgba(255, 255, 255, 0.3)');
                gradient.addColorStop(0.5, 'rgba(200, 200, 255, 0.2)');
                gradient.addColorStop(1, 'rgba(150, 150, 200, 0.05)');

                this.ctx.fillStyle = gradient;
                this.ctx.beginPath();
                
                // Draw irregular wispy shape
                for (let i = 0; i < Math.PI * 2; i += 0.1) {
                    const r = radius * (0.7 + 0.3 * Math.sin(i * 3 + ghost.pulsePhase));
                    const x = centerX + Math.cos(i) * r;
                    const y = centerY + Math.sin(i) * r * 1.2; // Elongated
                    if (i === 0) this.ctx.moveTo(x, y);
                    else this.ctx.lineTo(x, y);
                }
                this.ctx.closePath();
                this.ctx.fill();

                // Add ghostly tendrils
                this.ctx.strokeStyle = 'rgba(255, 255, 255, 0.1)';
                this.ctx.lineWidth = 2;
                for (let i = 0; i < 5; i++) {
                    this.ctx.beginPath();
                    this.ctx.moveTo(centerX, centerY + radius);
                    this.ctx.quadraticCurveTo(
                        centerX + (Math.random() - 0.5) * 50,
                        centerY + radius + 30,
                        centerX + (Math.random() - 0.5) * 30,
                        centerY + radius + 60
                    );
                    this.ctx.stroke();
                }
            }

            drawSolidGhost(ghost) {
                const centerX = ghost.x;
                const centerY = ghost.y;
                const size = ghost.size;

                // Draw a more solid, humanoid ghostly figure
                this.ctx.fillStyle = `rgba(240, 240, 255, ${ghost.opacity})`;
                this.ctx.strokeStyle = `rgba(200, 200, 255, ${ghost.opacity * 0.5})`;
                this.ctx.lineWidth = 3;

                // Head
                this.ctx.beginPath();
                this.ctx.arc(centerX, centerY - size * 0.3, size * 0.2, 0, Math.PI * 2);
                this.ctx.fill();
                this.ctx.stroke();

                // Body (flowing robe-like)
                this.ctx.beginPath();
                this.ctx.moveTo(centerX - size * 0.3, centerY - size * 0.1);
                this.ctx.quadraticCurveTo(centerX, centerY + size * 0.2, centerX + size * 0.3, centerY - size * 0.1);
                this.ctx.quadraticCurveTo(centerX + size * 0.2, centerY + size * 0.4, centerX + size * 0.1, centerY + size * 0.5);
                this.ctx.quadraticCurveTo(centerX, centerY + size * 0.3, centerX - size * 0.1, centerY + size * 0.5);
                this.ctx.quadraticCurveTo(centerX - size * 0.2, centerY + size * 0.4, centerX - size * 0.3, centerY - size * 0.1);
                this.ctx.fill();
                this.ctx.stroke();

                // Dark eye sockets
                this.ctx.fillStyle = `rgba(0, 0, 0, ${ghost.opacity * 0.8})`;
                this.ctx.beginPath();
                this.ctx.arc(centerX - size * 0.08, centerY - size * 0.35, size * 0.03, 0, Math.PI * 2);
                this.ctx.arc(centerX + size * 0.08, centerY - size * 0.35, size * 0.03, 0, Math.PI * 2);
                this.ctx.fill();
            }

            drawGhostOrb(ghost) {
                const centerX = ghost.x;
                const centerY = ghost.y;
                const radius = ghost.size / 3;

                // Glowing orb with energy trails
                const gradient = this.ctx.createRadialGradient(
                    centerX, centerY, 0,
                    centerX, centerY, radius
                );
                gradient.addColorStop(0, 'rgba(255, 255, 255, 0.8)');
                gradient.addColorStop(0.3, 'rgba(200, 255, 255, 0.6)');
                gradient.addColorStop(0.7, 'rgba(150, 200, 255, 0.3)');
                gradient.addColorStop(1, 'rgba(100, 150, 255, 0.1)');

                this.ctx.fillStyle = gradient;
                this.ctx.beginPath();
                this.ctx.arc(centerX, centerY, radius, 0, Math.PI * 2);
                this.ctx.fill();

                // Add sparkle effects
                this.ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
                for (let i = 0; i < 6; i++) {
                    const angle = (Date.now() * 0.001 + i) * 0.5;
                    const sparkleX = centerX + Math.cos(angle) * radius * 1.5;
                    const sparkleY = centerY + Math.sin(angle) * radius * 1.5;
                    this.ctx.beginPath();
                    this.ctx.arc(sparkleX, sparkleY, 2, 0, Math.PI * 2);
                    this.ctx.fill();
                }
            }

            drawDemonicPresence(demon) {
                const centerX = demon.x;
                const centerY = demon.y;
                const size = demon.size;

                // Dark, menacing presence
                const gradient = this.ctx.createRadialGradient(
                    centerX, centerY, 0,
                    centerX, centerY, size
                );
                gradient.addColorStop(0, 'rgba(100, 0, 0, 0.8)');
                gradient.addColorStop(0.3, 'rgba(50, 0, 0, 0.6)');
                gradient.addColorStop(0.7, 'rgba(20, 0, 0, 0.4)');
                gradient.addColorStop(1, 'rgba(0, 0, 0, 0.2)');

                this.ctx.fillStyle = gradient;
                this.ctx.beginPath();
                this.ctx.arc(centerX, centerY, size / 2, 0, Math.PI * 2);
                this.ctx.fill();

                // Glowing red eyes
                this.ctx.fillStyle = 'rgba(255, 0, 0, 0.9)';
                this.ctx.shadowColor = '#ff0000';
                this.ctx.shadowBlur = 20;
                this.ctx.beginPath();
                this.ctx.arc(centerX - size * 0.1, centerY - size * 0.1, 8, 0, Math.PI * 2);
                this.ctx.arc(centerX + size * 0.1, centerY - size * 0.1, 8, 0, Math.PI * 2);
                this.ctx.fill();
                this.ctx.shadowBlur = 0;

                // Dark tendrils reaching out
                this.ctx.strokeStyle = 'rgba(100, 0, 0, 0.6)';
                this.ctx.lineWidth = 5;
                for (let i = 0; i < 8; i++) {
                    const angle = (i / 8) * Math.PI * 2;
                    this.ctx.beginPath();
                    this.ctx.moveTo(centerX, centerY);
                    this.ctx.quadraticCurveTo(
                        centerX + Math.cos(angle) * size * 0.3,
                        centerY + Math.sin(angle) * size * 0.3,
                        centerX + Math.cos(angle) * size * 0.8,
                        centerY + Math.sin(angle) * size * 0.8
                    );
                    this.ctx.stroke();
                }
            }

            drawShadowFigure(shadow) {
                const x = shadow.x;
                const y = shadow.y;
                const width = shadow.width;
                const height = shadow.height;

                // Sway motion
                const swayOffset = Math.sin(Date.now() * shadow.sway + shadow.swayPhase) * 5;

                // Draw tall, ominous shadow figure
                this.ctx.fillStyle = `rgba(0, 0, 0, ${shadow.opacity})`;
                this.ctx.strokeStyle = `rgba(50, 50, 50, ${shadow.opacity * 0.5})`;
                this.ctx.lineWidth = 2;

                // Head
                this.ctx.beginPath();
                this.ctx.ellipse(x + swayOffset, y - height * 0.85, width * 0.15, width * 0.2, 0, 0, Math.PI * 2);
                this.ctx.fill();

                // Body
                this.ctx.beginPath();
                this.ctx.moveTo(x - width * 0.2 + swayOffset * 0.8, y - height * 0.7);
                this.ctx.lineTo(x + width * 0.2 + swayOffset * 0.8, y - height * 0.7);
                this.ctx.lineTo(x + width * 0.3 + swayOffset * 0.6, y - height * 0.3);
                this.ctx.lineTo(x + width * 0.25 + swayOffset * 0.4, y);
                this.ctx.lineTo(x - width * 0.25 + swayOffset * 0.4, y);
                this.ctx.lineTo(x - width * 0.3 + swayOffset * 0.6, y - height * 0.3);
                this.ctx.closePath();
                this.ctx.fill();

                // Make edges fade out
                const gradient = this.ctx.createLinearGradient(x - width, y, x + width, y);
                gradient.addColorStop(0, 'rgba(0, 0, 0, 0)');
                gradient.addColorStop(0.2, `rgba(0, 0, 0, ${shadow.opacity})`);
                gradient.addColorStop(0.8, `rgba(0, 0, 0, ${shadow.opacity})`);
                gradient.addColorStop(1, 'rgba(0, 0, 0, 0)');
                
                this.ctx.fillStyle = gradient;
                this.ctx.fillRect(x - width, y - height, width * 2, height);
            }

            drawRealisticEyes(eyes) {
                const x = eyes.x;
                const y = eyes.y;
                const size = eyes.size;
                const glowIntensity = eyes.glowIntensity;

                // Only draw if not blinking
                if (!eyes.isBlinking) {
                    // Outer glow
                    this.ctx.shadowColor = '#ff0000';
                    this.ctx.shadowBlur = glowIntensity * 30;
                    
                    // Left eye
                    this.ctx.fillStyle = 'rgba(255, 0, 0, 0.9)';
                    this.ctx.beginPath();
                    this.ctx.ellipse(x - size * 0.6, y, size * 0.4, size * 0.3, 0, 0, Math.PI * 2);
                    this.ctx.fill();

                    // Right eye  
                    this.ctx.beginPath();
                    this.ctx.ellipse(x + size * 0.6, y, size * 0.4, size * 0.3, 0, 0, Math.PI * 2);
                    this.ctx.fill();

                    this.ctx.shadowBlur = 0;

                    // Pupils
                    this.ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
                    this.ctx.beginPath();
                    this.ctx.ellipse(x - size * 0.6, y, size * 0.15, size * 0.15, 0, 0, Math.PI * 2);
                    this.ctx.ellipse(x + size * 0.6, y, size * 0.15, size * 0.15, 0, 0, Math.PI * 2);
                    this.ctx.fill();

                    // Reflective highlights
                    this.ctx.fillStyle = 'rgba(255, 100, 100, 0.6)';
                    this.ctx.beginPath();
                    this.ctx.ellipse(x - size * 0.55, y - size * 0.1, size * 0.05, size * 0.05, 0, 0, Math.PI * 2);
                    this.ctx.ellipse(x + size * 0.65, y - size * 0.1, size * 0.05, size * 0.05, 0, 0, Math.PI * 2);
                    this.ctx.fill();
                }
            }

            addScreenDistortion() {
                // Create temporary distortion effect
                const distortionCanvas = document.createElement('canvas');
                distortionCanvas.width = this.canvas.width;
                distortionCanvas.height = this.canvas.height;
                const distortCtx = distortionCanvas.getContext('2d');

                // Add static/noise effect
                const imageData = distortCtx.createImageData(this.canvas.width, this.canvas.height);
                for (let i = 0; i < imageData.data.length; i += 4) {
                    const noise = Math.random() * 255;
                    imageData.data[i] = noise;     // Red
                    imageData.data[i + 1] = 0;     // Green
                    imageData.data[i + 2] = 0;     // Blue
                    imageData.data[i + 3] = 50;    // Alpha
                }
                distortCtx.putImageData(imageData, 0, 0);

                // Overlay distortion on main canvas
                this.ctx.globalCompositeOperation = 'multiply';
                this.ctx.drawImage(distortionCanvas, 0, 0);
                this.ctx.globalCompositeOperation = 'source-over';
            }

            resetEffects() {
                this.ghosts = [];
                this.shadows = [];
                this.eyes = [];
                document.getElementById('glitchEffect').style.opacity = '0';
                document.getElementById('scanningGrid').style.opacity = this.currentEffect !== 'none' ? '0.3' : '0';
            }

            updateEffectInfo() {
                const info = document.getElementById('effectInfo');
                const description = document.getElementById('effectDescription');
                description.textContent = this.effects[this.currentEffect].description;
                
                if (this.currentEffect !== 'none') {
                    info.classList.add('show');
                    setTimeout(() => info.classList.remove('show'), 3000);
                } else {
                    info.classList.remove('show');
                }
            }

            async toggleRecording() {
                if (this.isRecording) {
                    this.stopRecording();
                } else {
                    await this.startRecording();
                }
            }

            async startRecording() {
                try {
                    // Create a composite stream with video + AR overlay
                    const canvas = document.createElement('canvas');
                    const ctx = canvas.getContext('2d');
                    canvas.width = this.video.videoWidth || 1280;
                    canvas.height = this.video.videoHeight || 720;

                    const compositeStream = canvas.captureStream(30);
                    
                    // Add audio track
                    const audioTrack = this.stream.getAudioTracks()[0];
                    if (audioTrack) {
                        compositeStream.addTrack(audioTrack);
                    }

                    // Composite video with AR effects
                    const renderFrame = () => {
                        if (!this.isRecording) return;
                        
                        ctx.drawImage(this.video, 0, 0, canvas.width, canvas.height);
                        ctx.drawImage(this.canvas, 0, 0, canvas.width, canvas.height);
                        
                        requestAnimationFrame(renderFrame);
                    };
                    renderFrame();

                    this.mediaRecorder = new MediaRecorder(compositeStream, {
                        mimeType: 'video/webm;codecs=vp9'
                    });

                    this.recordedChunks = [];
                    this.mediaRecorder.ondataavailable = (event) => {
                        if (event.data.size > 0) {
                            this.recordedChunks.push(event.data);
                        }
                    };

                    this.mediaRecorder.onstop = () => {
                        const blob = new Blob(this.recordedChunks, { type: 'video/webm' });
                        this.showPreview(blob);
                    };

                    this.mediaRecorder.start();
                    this.isRecording = true;
                    this.startTime = Date.now();
                    
                    this.updateRecordingUI(true);
                    this.startTimer();

                    // Auto-stop after max time
                    setTimeout(() => {
                        if (this.isRecording) {
                            this.stopRecording();
                        }
                    }, this.maxRecordTime * 1000);

                } catch (error) {
                    console.error('Recording error:', error);
                    this.updateStatus('Recording failed');
                }
            }

            stopRecording() {
                if (this.mediaRecorder && this.isRecording) {
                    this.mediaRecorder.stop();
                    this.isRecording = false;
                    this.updateRecordingUI(false);
                    this.stopTimer();
                }
            }

            updateRecordingUI(recording) {
                const recordBtn = document.getElementById('recordBtn');
                const recordingDot = document.getElementById('recordingDot');
                
                if (recording) {
                    recordBtn.classList.add('recording');
                    recordBtn.innerHTML = '⏹️';
                    recordingDot.style.display = 'block';
                    this.updateStatus('Recording...');
                } else {
                    recordBtn.classList.remove('recording');
                    recordBtn.innerHTML = '📹';
                    recordingDot.style.display = 'none';
                    this.updateStatus('Recording complete');
                }
            }

            startTimer() {
                const timer = document.getElementById('timer');
                timer.classList.add('show');
                
                this.timerInterval = setInterval(() => {
                    const elapsed = Math.floor((Date.now() - this.startTime) / 1000);
                    const minutes = Math.floor(elapsed / 60);
                    const seconds = elapsed % 60;
                    timer.textContent = `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
                }, 1000);
            }

            stopTimer() {
                const timer = document.getElementById('timer');
                timer.classList.remove('show');
                clearInterval(this.timerInterval);
            }

            showPreview(blob) {
                const previewVideo = document.getElementById('previewVideo');
                const previewModal = document.getElementById('previewModal');
                
                this.currentVideoBlob = blob;
                previewVideo.src = URL.createObjectURL(blob);
                previewModal.classList.add('show');
            }

            closePreview() {
                document.getElementById('previewModal').classList.remove('show');
                if (this.currentVideoBlob) {
                    URL.revokeObjectURL(document.getElementById('previewVideo').src);
                }
            }

            recordAgain() {
                this.closePreview();
            }

            downloadVideo() {
                if (this.currentVideoBlob) {
                    const link = document.createElement('a');
                    link.href = URL.createObjectURL(this.currentVideoBlob);
                    link.download = `haunted-video-${Date.now()}.webm`;
                    link.click();
                    this.updateStatus('Video downloaded');
                }
            }

            async shareVideo() {
                if (navigator.share && this.currentVideoBlob) {
                    const file = new File([this.currentVideoBlob], 'haunted-video.webm', { type: 'video/webm' });
                    try {
                        await navigator.share({
                            title: '👻 Haunted AR Video',
                            text: 'Check out this spooky video I made with Haunted AR Camera!',
                            files: [file]
                        });
                    } catch (error) {
                        this.downloadVideo(); // Fallback
                    }
                } else {
                    this.downloadVideo(); // Fallback
                }
            }

            async switchCamera() {
                try {
                    const currentTrack = this.stream.getVideoTracks()[0];
                    const currentFacingMode = currentTrack.getSettings().facingMode;
                    const newFacingMode = currentFacingMode === 'user' ? 'environment' : 'user';
                    
                    currentTrack.stop();
                    
                    const newStream = await navigator.mediaDevices.getUserMedia({
                        video: { facingMode: newFacingMode },
                        audio: true
                    });
                    
                    this.video.srcObject = newStream;
                    this.stream = newStream;
                    
                } catch (error) {
                    console.error('Camera switch error:', error);
                }
            }

            updateStatus(message) {
                document.getElementById('statusText').textContent = message;
            }
        }

        // Initialize the app
        window.addEventListener('load', () => {
            new HauntedARCamera();
        });
    </script>
</body>
</html>